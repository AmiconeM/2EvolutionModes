---
title: "Analyse mutation trajectories - Sojour times"
author: "Amicone Massimo"
date: "24/11/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(writexl)
library(RColorBrewer)
library(xlsx)
```

## What conditions do you want to compare?
Set the parameters that correspond to the conditions you want to analyse.
```{r, set parameters}
# parameters to change

model="DirSel_Gamma_shape1"                    ## model used for the simulations
Us=c(10^(-9),10^(-8),10^(-7),10^(-6),10^(-5))  ## mutation rates used for the simulations
N=10^7                                         ## pop size used for the simulations
Pb=1                                           ## proportion of ben. mutations used for the simulations
Delta=0.05                                     ## expected mutation effect used for the simulations
simulations=20                                 ## number of simulations
seed=0                                         ## random seed used for the simulations
t_tot=10000                                    ## number of generations used for the simulations
p_sample=100                                   ## sampling period
inFit=1                                        ## initial population fitness used for the simulations

```

## Color code for the different conditions  
The colors will distinguish the different mutation rate conditions.
Change pallette in case you need more than 9.
```{r,colors}
colors=brewer.pal(n=length(Us),name="Set1") ### change pallette in case you need more than 9 colors
light_colors=c()                            ### to create the same colors but 20% transparent
med_colors=c()                              ### to create the same colors but 50% transparent
for(i in 1:length(Us)){
  col=col2rgb(colors[i])
  c_light=rgb(col[1]/255,col[2]/255,col[3]/255,0.8)
  c_med=rgb(col[1]/255,col[2]/255,col[3]/255,0.5)
  light_colors=c(light_colors,c_light)
  med_colors=c(med_colors,c_med)
}
```

```{r,colors2}
color_range <- colorRampPalette(c("#2D3919", "#99BB63"))
colors=color_range(length(Us)) 
#colors=brewer.pal(n=length(Us),name="Set1") ### change pallette in case you need more than 9 colors
light_colors=c()                            ### to create the same colors but 20% transparent
med_colors=c()                              ### to create the same colors but 50% transparent
for(i in 1:length(Us)){
  col=col2rgb(colors[i])
  c_light=rgb(col[1]/255,col[2]/255,col[3]/255,0.8)
  c_med=rgb(col[1]/255,col[2]/255,col[3]/255,0.5)
  light_colors=c(light_colors,c_light)
  med_colors=c(med_colors,c_med)
}
```

## If you need to compute the sojourn time, run the following box (called "Compute Sojour times").
## If you have computed it previously, upload directly the sojourn file from box "load pre-analyzed dataset".

## Load mutation trajectories and compute sojour times 
The next box will import the data from different mutation rate conditions, compile them in a dataframe called Sojour_Data and export an Excel file with the analysed sojour data.  

After loading the mutation trajectory data, for each population this code performs the following steps:
i) count the number of observed mutations  
ii) Add an additional time point, where every polymorphic mutation is given frequency 1.
Mutations that are polymorphic at the end of the simulation are then given frequency 1. This step is to allow the computation of sojour time and give those mutation a finite sojour time (which depends on the duration of the experiment), instead of infinity. 
 
iii) Compute time needed to go from frequency 0.01 (minimum observable frequency) to a given frequency, f.
(here f takes the values between 0.01 and 1, with intervals of 0.01 (e.g. 0.01, 0.02, ...))
In particular, the sojour time until frequency x, is computed by:
- get the first time point (T0) for which f>=0.01.
- get the first time point (T1) for which f>=x.
- If T0=T1 it means that the mutation has reached frequency x in a time smaller than the sampling period (here 100 generations). In this case the sojour time until x is assumed proportional to the frequency itself: s_time=100*x.
- If T0!=T1 (T0<T1), then the sojour time is computed as: s_time=(T1-T0)*p_sample

iv) export a table with sojour times for each population/condition.
```{r,Compute Sojour times}
f_min=0.01
f_max=0.99


NU_b=c()
Model=c()
W0=c()
Mut_effect=c()
Freq=c()
pop_ID=c()
Freq_interval=seq(0.01,1,0.01)
S_Times=c()

t_final=7500 ## final time point
t_column=t_final/100 +3 ##set the data column (time point) where to stop the analysis

for(u in 1:length(Us)){
  ##load data
  
  input_file=paste("Data_U",Us[u],"_N1e+07_Delta",Delta,"_Pb",Pb,"_W0_",inFit,"_",t_tot,"gen_",simulations,"sim_seed",seed,"_",model,"/Mut_Trajectories_U",Us[u],"_N1e+07_Delta",Delta,"_Pb",Pb,"_W0_",inFit,"_",t_tot,"gen_",simulations,"sim_seed",seed,"_",model,".csv",sep="")
  data=read.table(file=input_file,header = T,sep =",")
  
  ## compute DAF for each population
  for(replica in 1:simulations){
    print(paste("U:",Us[u],", replica:",replica),sep="")
    data_p=data[which(data$pop_ID==replica),3:t_column]
    
    ## i) count the number of observed mutations 
    mutations=dim(data_p)[1]
    if(mutations>0){
      ## ii) Add an additional time point, where every polymorphic mutation is given frequency 1.
      data_p$end=0
      fix=which(data_p[,dim(data_p)[2]-1]>0)
      data_p$end[fix]=1
      
      ##compute the max frequency of each mutation
      max_f=c()
      for(m in 1:mutations){
        max_f=c(max_f,max(data_p[m,]))
      }
      
      ## iii) Compute time needed to go from frequency 0.01 (minimum observable frequency) to a given frequency, f.
      ## (here f takes the values between 0.01 and 1, with intervals of 0.01 (e.g. 0.01, 0.02, ...))  
     
      for(f in 1:length(Freq_interval)){
        f_t=Freq_interval[f]
        data_f=data_p[which(max_f>=f_t),]
        mutations=dim(data_f)[1]
        s_time=0
        for(m in 1:mutations){
          traj=data_f[m,]
          ## get first and last time point
          t_e=min(which(traj>=f_min))
          t_f=min(which(traj>=f_t))
          m_time=max((t_f-t_e)*p_sample,p_sample*f_t) ##if t_f==t_e then the sojour time is a portion of the sampling period
          s_time=s_time+m_time
          
        }
        S_Times=c(S_Times,s_time/mutations)
        Freq=c(Freq,f_t)
        NU_b=c(NU_b,N*Us[u]*Pb)
        Model=c(Model,model)
        W0=c(W0,inFit)
        Mut_effect=c(Mut_effect,Delta)
        pop_ID=c(pop_ID,replica)
      }
    }else{S_Times=c(S_Times,rep(NA,length(Freq_interval)))
        Freq=c(Freq,Freq_interval)
        NU_b=c(NU_b,rep(N*Us[u]*Pb,length(Freq_interval)))
        Model=c(Model,rep(model,length(Freq_interval)))
        W0=c(W0,rep(inFit,length(Freq_interval)))
        Mut_effect=c(Mut_effect,rep(Delta,length(Freq_interval)))
        pop_ID=c(pop_ID,rep(replica,length(Freq_interval)))}
    
  }
}

## iv) export a table with sojour times for each population/condition.
Sojour_Data=data.frame(NU_b,Mut_effect,W0,Model,pop_ID,Freq,S_Times)
write_xlsx(Sojour_Data, paste("Sojour_time_",model,"_s",Delta,"_",t_final,"generations",".xlsx",sep=""))
```


##Load Sojourn data
```{r, load pre-analyzed dataset}
t_final=10000 ## final time point
Sojour_Data=read.xlsx(paste("Sojour_time_",model,"_s",Delta,"_",t_final,"generations",".xlsx",sep=""),sheetIndex = 1)

```


##Plotting
Thin lines represent single populations.
Thick lines represent the mean across populations.

```{r,Plot St across NUb}
Freq_interval=seq(0.01,1,0.01)
f_min=0.01
f_max=0.99

colnames(Sojour_Data)=c("NUb","Mutation effect","W0","Model","pop_ID","Frequency","Sojour")

x=Freq_interval
y=rep(0,length(x))

Sojour_Data$NUb=as.factor(Sojour_Data$NUb)

y_title=expression("Avg. time to reach x")
x_title=expression("Frequency, x")

Y_medians=matrix(0,nrow = length(Us),ncol=length(x))
Y_means=matrix(0,nrow = length(Us),ncol=length(x))
Y_SEMs=matrix(0,nrow = length(Us),ncol=length(x))
Y_q1=matrix(0,nrow = length(Us),ncol=length(x))
Y_q3=matrix(0,nrow = length(Us),ncol=length(x))

label=expression("t="~1/hat(s)~ "*" ~log((f[i]*(1-f[0]))/(f[0]*(1-f[i]))))
label2=expression("t="~1/hat(s)~ "*" ~log((f[i]*(1-f[0]))/(f[0]*(1-f[i]))))

title=expression("Directional selection ("  ~  hat(s) ~  "=" ~ 0.05 ~ ", N ="~ 10^7 ~")")
#tiff(file=paste("Sojour_times_",model,"_s",Delta,"_all.tiff",sep=""),width=6, height=5,res = 300,units = "in")
png(file=paste("Sojour_times_",model,"_s",Delta,"_",t_final,"generations.png",sep=""),width=5, height=5,res = 600,units = "in")
par(las=1,mar=c(5.1, 4.1, 4.1, 7.1), xpd=TRUE)
t_fin=20*Delta
plot(x=x,y=y,type='n',xlab="",ylab="",xaxt='n',yaxt='n',ylim = c(0,400),xlim = c(0,1))
for(u in 1:length(Us)){
  nu_b=N*Pb*Us[u]
  rm(SJ)
  for(replica in 1:simulations){
    sj=Sojour_Data$Sojour[intersect(which(Sojour_Data$NUb==nu_b),which(Sojour_Data$pop_ID==replica))]
    #sj=sj*Delta
    SJ=rbind(get0("SJ"),sj)
    lines(x=Freq_interval,y=sj,col=colors[u],lwd=0.3)
  }
  ## expectation under infinite pop size
  y_expected=c()
  
  x_ex=c(seq(f_min,f_max,0.01),0.995)
  for(i in 1:length(x_ex)){
    y_expected=c(y_expected,(log((x_ex[i]*(1-f_min))/(f_min*(1-x_ex[i]))))/Delta)
  }
  
  y_median=c()
  y_q1=c()
  y_q3=c()
  y_mean=c()
  y_SEM=c()
  for(i in 1:length(x)){
    y_median=c(y_median,quantile(SJ[,i],0.5,na.rm = T))
    y_mean=c(y_mean,mean(SJ[,i],na.rm = T))
    SD=sd(SJ[,i],na.rm = T)
    y_SEM=c(y_SEM,2*SD/sqrt(simulations))
    y_q1=c(y_q1,quantile(SJ[,i],0.25,na.rm = T))
    y_q3=c(y_q3,quantile(SJ[,i],0.75,na.rm = T))
  }
  
  Y_medians[u,]=y_median
  Y_q1[u,]=y_q1
  Y_q3[u,]=y_q3
  Y_means[u,]=y_mean
  Y_SEMs[u,]=y_SEM
} 
for(u in 1:length(Us)){
  #plot median
  #polygon(c(x,rev(x)), c(Y_q1[u,],rev(Y_q3[u,])),border=NA, col=med_colors[u])
  #lines(x=x,y=Y_medians[u,],col=colors[u],lwd=4)
  
  #plot mean
  polygon(c(x,rev(x)), c(Y_means[u,]+Y_SEMs[u,],rev(Y_means[u,]-Y_SEMs[u,])),border=NA, col=med_colors[u])
  lines(x=x,y=Y_means[u,],col=colors[u],lwd=4)
}
xtick=seq(0,1,length.out = 6)
axis(side=1,at=xtick,tck=-0.01,labels = FALSE)
text(x=xtick,  par("usr")[3],labels = xtick,pos = 1, xpd = TRUE)

ytick=seq(0,400,100)
axis(side=2,at=ytick,tck=-0.01,labels = FALSE)
text(par("usr")[1], ytick,labels = ytick, pos = 2, xpd = TRUE)

title(xlab = x_title, mgp = c(1.5,1,0))    # Add x-axis text
title(ylab = y_title, mgp = c(2, 1, 0))    # Add y-axis text

legend("right", bty = "n", col=colors,pch=15,cex=1.5,legend = levels(Sojour_Data$NUb),title = expression(NU[b]),inset=c(-0.4,0),pt.cex = 3)
#legend("top", bty = "n", col="#161D0C",lty=c(2),legend = c(label),lwd=3,cex = 0.8)
lines(x=x_ex,y=y_expected,lty=2,lwd=3,col="#161D0C")

#text(x=0.85,y=25,labels=paste("T(.95)/T(.3)=",round(y_expected[95]/y_expected[30],digits = 2)),col="darkred",cex=0.8)
dev.off()

```




